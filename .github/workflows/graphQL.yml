# .github/workflows/graphql‐graphiql-smoke‐tests.yml
name: CI - GraphiQL Smoke Test (OAuth2 login → GET /graphiql)

on:
  push:
    branches: [ pipelines ]
  pull_request:
    branches: [ pipelines ]

jobs:
  graphiqlsmoke:
    name: Build, Login & Check /graphiql
    runs-on: ubuntu-latest

    env:
      TZ: Europe/Prague
      DEMO_EMAIL: john.newbie@world.com
      DEMO_PASSWORD: john.newbie@world.com

    steps:
      # 1) Checkout repozitáře
      - name: Checkout repository
        uses: actions/checkout@v3

      # 2) Spustit Docker Compose (OAuth2 server + GraphQL backend)
      - name: Start Docker Compose stack
        shell: bash
        run: |
          echo "==> Spouštím Docker Compose stack na pozadí…"
          docker compose -f docker-compose.hk2025.yml up -d --build

      # 3) Počkat, až služby dokončí healthcheck
      - name: Wait for services to be healthy
        shell: bash
        run: |
          echo "Čekám 30 sekund, aby se služby nachystaly…"
          sleep 30

      # 4) (volitelně) Zkontrolovat běžící kontejnery
      - name: Check running containers
        shell: bash
        run: |
          echo "=== Seznam všech Docker kontejnerů před testem: ==="
          docker ps -a

      ######################################################################
      # Krok 1: OAuth2 login → stáhnout login stránku, extrahovat key, poslat POST,
      #           a uložit výslednou cookie "authorization"
      ######################################################################
      - name: Perform OAuth2 login and save authorization cookie
        id: login_step
        shell: bash
        run: |
          echo "==> 1) Stahuji login stránku (pro získání 'key' + počáteční cookie)…"
          COOKIE_INIT="cookies_init.txt"
          LOGIN_HTML="login.html"
          LOGIN_URL="http://localhost:33001/oauth/login2?redirect_uri=/"

          # 1. GET login form (uložíme cookies_init.txt + login.html)
          curl -s -L "$LOGIN_URL" \
            -c "$COOKIE_INIT" \
            -o "$LOGIN_HTML"

          # Debug: vypišme první řádky login.html, ať je jasné, že to sedí
          echo "→ Obsah login.html (prvních 20 řádků):"
          head -n 20 "$LOGIN_HTML" || true
          echo "…"

          # 2. Extrahovat skrytý 'key' z HTML (value bez uvozovek)
          echo "==> 2) Extrahuji 'key' ze staženého HTML…"
          KEY=$(grep -oP 'name="key".*?value=\K[^ >]+' "$LOGIN_HTML" || true)
          if [ -z "$KEY" ]; then
            echo "❌ Chyba: Nepodařilo se najít hodnotu 'key' v $LOGIN_HTML!"
            echo "- Níže celý login.html pro debug:"
            cat "$LOGIN_HTML"
            exit 1
          fi
          echo "→ Nalezen KEY: $KEY"

          # 3. POST přihlášení (username + password + key) → uloží se do cookies_auth.txt
          echo "==> 3) Posílám POST s přihlášením (username + password + key)…"
          COOKIE_AUTH="cookies_auth.txt"
          curl -s -L "$LOGIN_URL" \
            -b "$COOKIE_INIT" \
            -c "$COOKIE_AUTH" \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "username=${DEMO_EMAIL}" \
            -d "password=${DEMO_PASSWORD}" \
            -d "key=${KEY}" \
            -o /dev/null

          # Ověřit, že cookies_auth.txt existuje a není prázdný
          if [ ! -s "$COOKIE_AUTH" ]; then
            echo "❌ Chyba: Nepodařilo se uložit cookie do $COOKIE_AUTH."
            ls -l "$COOKIE_AUTH" || true
            exit 1
          fi

          # Debug: zobrazit celý obsah cookies_auth.txt
          echo "→ Obsah cookies_auth.txt:"
          cat "$COOKIE_AUTH"

          # 4. Z cookies_auth.txt vyextrahovat hodnotu cookie 'authorization'
          JWT_COOKIE=$(grep -i "authorization" "$COOKIE_AUTH" | awk '{print $7}' | head -n 1 || true)
          if [ -z "$JWT_COOKIE" ]; then
            echo "❌ Chyba: V cookie-jar nebyla nalezena cookie 'authorization'!"
            exit 1
          fi

          echo "→ Extrahovaná hodnota authorization cookie: $JWT_COOKIE"
          # Uložit JWT (authorization) do GitHub kelu pro další kroky
          echo "AUTHORIZATION=$JWT_COOKIE" >> "$GITHUB_OUTPUT"
          echo "✅ OAuth2 login proběhl, authorization cookie uložena."

      ######################################################################
      # Krok 2: Ověřím, že GET /graphiql/ vrátí 200 OK (pomocí uložené cookie)
      ######################################################################
      - name: Smoke test GraphiQL UI (GET /graphiql)
        id: graphiql_ui_test
        shell: bash
        env:
          AUTHORIZATION: ${{ steps.login_step.outputs.AUTHORIZATION }}
        run: |
          echo "==> 2) GET /graphiql/ s cookie authorization…"
          if [ -z "${AUTHORIZATION}" ]; then
            echo "❌ Chyba: V proměnné AUTHORIZATION není žádný token! (login selhal nebo cookie nebyla nastavena)"
            exit 1
          fi

          # Provedeme GET a zkontrolujeme stav (200) a přítomnost textu "GraphiQL" v HTML
          RESPONSE_HTTP_CODE=$(
            curl -s -o /dev/null -w "%{http_code}" \
              -H "Cookie: authorization=${AUTHORIZATION}" \
              http://localhost:33001/graphiql/
          )
          echo "→ HTTP status: $RESPONSE_HTTP_CODE"
          if [ "$RESPONSE_HTTP_CODE" != "200" ]; then
            echo "❌ Chyba: /graphiql/ vrací HTTP $RESPONSE_HTTP_CODE namísto 200."
            exit 1
          fi
          echo "✅ HTTP 200 OK - GraphiQL endpoint dostupný."

          # Nyní se podíváme na část HTML, abychom viděli, že obsahuje "GraphiQL"
          BODY=$(curl -s \
            -H "Cookie: authorization=${AUTHORIZATION}" \
            http://localhost:33001/graphiql/ \
          )
          echo "→ Výřez z HTML GraphiQL (prvních 200 znaků):"
          echo "${BODY:0:200}" | sed 's/<[^>]*>/ /g'
          echo "…"

          # Ovĕříme, že stránka skutečně obsahuje GraphiQL UI (hledáme "GraphiQL" v HTML)
          echo "$BODY" | grep -i "GraphiQL" \
            && echo "✅ Stránka obsahuje 'GraphiQL'." \
            || (echo "❌ Stránka neobsahuje 'GraphiQL'." && exit 1)

      ######################################################################
      # Krok 3: Introspekční query (cookie + XSRF) -> /api/gql
      ######################################################################
      - name: Introspect GraphQL Schema (POST /api/gql)
        id: introspect_schema
        shell: bash
        env:
          AUTHORIZATION: ${{ steps.login_step.outputs.AUTHORIZATION }}
        run: |
          echo "==> 3) Provedu introspekční dotaz na /api/gql pouze s cookie authorization…"
          if [ -z "${AUTHORIZATION}" ]; then
            echo "❌ Chyba: AUTHORIZATION cookie je prázdná!"
            exit 1
          fi

          # Definice introspekčního GraphQL dotazu
          INTROSPECTION_QUERY='{ "query": "{ __schema { types { name } } }" }'

          echo "==> Posílám GraphQL introspection query…"
          echo "→ Query: $INTROSPECTION_QUERY"
          echo "→ Cookie: authorization=${AUTHORIZATION:0:50}..."

          # POST na /api/gql se samotnou hlavičkou Cookie: authorization=…
          # Důležité: Uložíme jak HTTP status kód, tak response body
          HTTP_STATUS=$(curl -s -w "%{http_code}" -o response.json -X POST http://localhost:33001/api/gql \
            -H "Content-Type: application/json" \
            -H "Cookie: authorization=${AUTHORIZATION}" \
            --data "$INTROSPECTION_QUERY")

          echo "→ HTTP Status: $HTTP_STATUS"

          # Zkontrolujeme HTTP status
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "❌ Chyba: GraphQL endpoint vrací HTTP $HTTP_STATUS namísto 200."
            echo "Response body:"
            cat response.json 2>/dev/null || echo "Nelze přečíst response.json"
            exit 1
          fi

          # Zobrazíme response pro debug
          echo "=== GraphQL Response (prvních 500 znaků): ==="
          head -c 500 response.json 2>/dev/null || echo "Nelze přečíst response.json"
          echo
          echo "==="

          # Ověříme, že response.json existuje a není prázdný
          if [ ! -s response.json ]; then
            echo "❌ Chyba: Response je prázdný nebo neexistuje!"
            exit 1
          fi

          # Ověříme, že v odpovědi vidíme "__schema" - použijeme jq pokud je dostupné, jinak grep
          if command -v jq >/dev/null 2>&1; then
            echo "→ Používám jq pro parsování JSON..."
            SCHEMA_FOUND=$(jq -r '.data.__schema' response.json 2>/dev/null || echo "null")
            if [ "$SCHEMA_FOUND" != "null" ] && [ "$SCHEMA_FOUND" != "" ]; then
              echo "✅ Introspection OK - našel jsem __schema pomocí jq."
            else
              echo "❌ Introspection selhala - nenalezen __schema v JSON struktuře."
              echo "Celá response:"
              cat response.json
              exit 1
            fi
          else
            echo "→ jq není dostupné, používám grep..."
            if grep -q '"__schema"' response.json; then
              echo "✅ Introspection OK - našel jsem __schema pomocí grep."
            else
              echo "❌ Introspection selhala - nenalezen __schema v response."
              echo "Celá response:"
              cat response.json
              exit 1
            fi
          fi

          # Dodatečná kontrola - počet typů ve schématu
          if command -v jq >/dev/null 2>&1; then
            TYPE_COUNT=$(jq -r '.data.__schema.types | length' response.json 2>/dev/null || echo "0")
            echo "→ Počet typů ve schématu: $TYPE_COUNT"
            if [ "$TYPE_COUNT" -gt "0" ]; then
              echo "✅ Schema obsahuje $TYPE_COUNT typů."
            else
              echo "⚠️  Varování: Schema neobsahuje žádné typy nebo nelze parsovat."
            fi
          fi

      ########################################################################
      # Krok 4: Tear down Docker Compose
      ########################################################################
      - name: Tear down Docker Compose stack
        if: always()
        shell: bash
        run: |
          echo "==> Clean up: Ukončuji Docker Compose stack…"
          docker compose -f docker-compose.hk2025.yml down --volumes